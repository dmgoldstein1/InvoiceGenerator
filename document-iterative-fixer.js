#!/usr/bin/env node

/**
 * Generated by GitHub Copilot (GPT-4o)
 * Complete Document Comparison and Iterative Fixer
 * 
 * Compares both cover letter and invoice against templates,
 * identifies differences, implements fixes, and iterates until perfect.
 */

const fs = require('path');
const path = require('path');
const RobustPdfExtractor = require('./robust-pdf-extractor');
const PreciseTemplateGenerator = require('./precise-template');

class DocumentIterativeFixer {
  constructor() {
    this.extractor = new RobustPdfExtractor();
    this.iteration = 0;
    this.maxIterations = 5;
    this.differences = [];
  }
  
  async compareDocuments() {
    this.iteration++;
    console.log(`\n=== ITERATION ${this.iteration}: DOCUMENT COMPARISON ===\n`);
    
    // Extract template texts
    const templateCoverLetter = await this.extractor.analyzePdf('Invoice 21 for SAV-for-template.pdf');
    const generatedCoverLetter = await this.extractor.analyzePdf('output/precise-template-test-cover-letter.pdf');
    const generatedInvoice = await this.extractor.analyzePdf('output/precise-template-test-invoice.pdf');
    
    if (!templateCoverLetter || !generatedCoverLetter || !generatedInvoice) {
      console.log('‚ùå Failed to extract PDF content');
      return false;
    }
    
    this.differences = [];
    
    // Compare cover letters
    this.compareCoverLetters(templateCoverLetter, generatedCoverLetter);
    
    // Compare invoice titles (template has both docs, generated has separate files)
    this.compareInvoiceTitles(templateCoverLetter, generatedInvoice);
    
    // Generate comparison report
    this.generateComparisonReport();
    
    return this.differences.length === 0;
  }
  
  compareCoverLetters(template, generated) {
    console.log('üîç COMPARING COVER LETTERS...\n');
    
    // Extract just the cover letter portion from template (first page)
    const templateText = template.allText.split('\\f')[0]; // First page only
    const generatedText = generated.allText;
    
    console.log('Template Cover Letter Title:', template.title);
    console.log('Generated Cover Letter Title:', generated.title);
    
    if (template.title !== generated.title) {
      console.log('‚ùå DIFFERENCE: Cover letter titles differ');
      this.differences.push({
        type: 'cover_letter_title',
        severity: 'low',
        template: template.title,
        generated: generated.title,
        status: 'SAME - Both have "for Services Rendered"'
      });
    } else {
      console.log('‚úÖ MATCH: Cover letter titles are identical');
    }
    
    // Compare phone numbers
    console.log('\\nTemplate phones:', template.phoneNumbers);
    console.log('Generated phones:', generated.phoneNumbers);
    
    const templatePhones = template.phoneNumbers.join(',');
    const generatedPhones = generated.phoneNumbers.join(',');
    
    if (templatePhones !== generatedPhones) {
      console.log('‚ùå DIFFERENCE: Phone numbers differ');
      this.differences.push({
        type: 'phone_numbers',
        severity: 'low',
        template: templatePhones,
        generated: generatedPhones
      });
    } else {
      console.log('‚úÖ MATCH: Phone numbers are identical');
    }
    
    // Compare structure
    const templateHasGreeting = templateText.includes('Hello Dr. Sandy');
    const generatedHasGreeting = generatedText.includes('Hello Dr. Sandy');
    
    console.log('\\nTemplate has greeting:', templateHasGreeting);
    console.log('Generated has greeting:', generatedHasGreeting);
    
    if (templateHasGreeting !== generatedHasGreeting) {
      this.differences.push({
        type: 'greeting_presence',
        severity: 'medium',
        template: templateHasGreeting,
        generated: generatedHasGreeting
      });
    } else {
      console.log('‚úÖ MATCH: Both have proper greeting');
    }
  }
  
  compareInvoiceTitles(templateDoc, generatedInvoice) {
    console.log('\\nüîç COMPARING INVOICE TITLES...\\n');
    
    // Template invoice is on second page
    const templateInvoiceText = templateDoc.allText.split('\\f')[1] || templateDoc.allText;
    
    // Look for invoice title in template second page
    const templateInvoiceTitle = templateInvoiceText.match(/Invoice #\\d+[^\\n]*/)?.[0];
    const generatedInvoiceTitle = generatedInvoice.title;
    
    console.log('Template Invoice Title:', templateInvoiceTitle);
    console.log('Generated Invoice Title:', generatedInvoiceTitle);
    
    if (templateInvoiceTitle && generatedInvoiceTitle) {
      if (templateInvoiceTitle !== generatedInvoiceTitle) {
        console.log('‚ùå CRITICAL DIFFERENCE: Invoice titles differ!');
        this.differences.push({
          type: 'invoice_title',
          severity: 'critical',
          template: templateInvoiceTitle,
          generated: generatedInvoiceTitle,
          fix: 'Template invoice has different title format'
        });
      } else {
        console.log('‚úÖ MATCH: Invoice titles are identical');
      }
    }
    
    // Compare headers from invoice page
    console.log('\\nChecking for "Amount Billed" in template invoice...');
    const templateHasAmountBilled = templateInvoiceText.includes('Amount Billed');
    const generatedHasAmountBilled = generatedInvoice.allText.includes('Amount Billed');
    
    console.log('Template has "Amount Billed":', templateHasAmountBilled);
    console.log('Generated has "Amount Billed":', generatedHasAmountBilled);
    
    if (templateHasAmountBilled !== generatedHasAmountBilled) {
      this.differences.push({
        type: 'amount_billed_header',
        severity: 'medium',
        template: templateHasAmountBilled,
        generated: generatedHasAmountBilled
      });
    } else {
      console.log('‚úÖ MATCH: Both use "Amount Billed" header');
    }
  }
  
  generateComparisonReport() {
    console.log(`\\n=== ITERATION ${this.iteration} RESULTS ===\\n`);
    
    if (this.differences.length === 0) {
      console.log('üéâ PERFECT MATCH ACHIEVED!');
      console.log('‚úÖ All documents match template exactly');
      console.log('‚úÖ Cover letters are identical');
      console.log('‚úÖ Invoice titles are identical');
      console.log('‚úÖ Headers and formatting match');
      return true;
    }
    
    console.log(`‚ùå Found ${this.differences.length} differences:`);
    
    this.differences.forEach((diff, index) => {
      console.log(`\\n${index + 1}. ${diff.type.toUpperCase()} (${diff.severity})`);
      console.log(`   Template: ${diff.template}`);
      console.log(`   Generated: ${diff.generated}`);
      if (diff.fix) {
        console.log(`   Fix: ${diff.fix}`);
      }
    });
    
    const critical = this.differences.filter(d => d.severity === 'critical').length;
    const medium = this.differences.filter(d => d.severity === 'medium').length;
    const low = this.differences.filter(d => d.severity === 'low').length;
    
    console.log(`\\nüìä Summary: ${critical} critical, ${medium} medium, ${low} low severity`);
    
    return false;
  }
  
  async implementFixes() {
    console.log('\\nüîß IMPLEMENTING FIXES...\\n');
    
    const criticalFixes = this.differences.filter(d => d.severity === 'critical');
    
    if (criticalFixes.length === 0) {
      console.log('‚úÖ No critical fixes needed');
      return true;
    }
    
    for (const fix of criticalFixes) {
      console.log(`Implementing fix for: ${fix.type}`);
      
      switch (fix.type) {
        case 'invoice_title':
          // This suggests the template invoice has a different title format
          // We need to check what the actual template invoice title is
          console.log('üîç Need to verify template invoice title format');
          break;
        default:
          console.log(`No automatic fix available for: ${fix.type}`);
      }
    }
    
    return false; // Fixes need manual implementation
  }
  
  async regenerateAndTest() {
    console.log('\\nüîÑ REGENERATING DOCUMENTS...\\n');
    
    const generator = new PreciseTemplateGenerator();
    
    try {
      const files = await generator.generateFromYaml(
        'cover_letter_and_invoice_example.yaml',
        `iteration-${this.iteration}-test`
      );
      
      console.log('‚úÖ Documents regenerated successfully');
      console.log('Cover Letter:', files.coverLetter);
      console.log('Invoice:', files.invoice);
      
      return true;
    } catch (error) {
      console.log('‚ùå Failed to regenerate documents:', error.message);
      return false;
    }
  }
  
  async runIterativeImprovement() {
    console.log('üöÄ Starting iterative document improvement process...\\n');
    
    while (this.iteration < this.maxIterations) {
      // Step 1: Compare documents
      const isMatch = await this.compareDocuments();
      
      if (isMatch) {
        console.log(`\\nüéØ PERFECT MATCH ACHIEVED IN ${this.iteration} ITERATIONS!`);
        return true;
      }
      
      // Step 2: Implement fixes (if possible)
      const fixesImplemented = await this.implementFixes();
      
      if (!fixesImplemented) {
        console.log('\\n‚ö†Ô∏è  Manual fixes required - stopping iteration');
        break;
      }
      
      // Step 3: Regenerate documents
      const regenerated = await this.regenerateAndTest();
      
      if (!regenerated) {
        console.log('\\n‚ùå Failed to regenerate - stopping iteration');
        break;
      }
    }
    
    console.log(`\\nüìä FINAL RESULTS AFTER ${this.iteration} ITERATIONS:`);
    console.log(`Remaining differences: ${this.differences.length}`);
    
    return this.differences.length === 0;
  }
}

// Run the iterative improvement process
if (require.main === module) {
  const fixer = new DocumentIterativeFixer();
  
  fixer.runIterativeImprovement()
    .then(success => {
      if (success) {
        console.log('\\nüéâ TEMPLATE MATCHING COMPLETE!');
      } else {
        console.log('\\n‚ö†Ô∏è  Template matching requires manual intervention');
      }
    })
    .catch(error => {
      console.error('Process failed:', error.message);
      process.exit(1);
    });
}

module.exports = DocumentIterativeFixer;
