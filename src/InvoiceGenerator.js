/**
 * Generated by GitHub Copilot (GPT-4)
 * Invoice Generator - Main PDF generation class
 * 
 * This class handles the creation of professionally formatted PDF invoices
 * from structured data, matching the styling of the provided template.
 */

const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

class InvoiceGenerator {
    constructor(options = {}) {
        this.options = {
            fontSize: {
                title: 28,
                heading: 16,
                subheading: 12,
                body: 10,
                small: 8
            },
            colors: {
                primary: '#2c3e50',
                secondary: '#7f8c8d',
                accent: '#3498db',
                tableHeader: '#ecf0f1',
                tableAlt: '#f8f9fa',
                border: '#bdc3c7',
                lightBorder: '#ecf0f1'
            },
            margins: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            fonts: {
                regular: 'Helvetica',
                bold: 'Helvetica-Bold',
                light: 'Helvetica'
            },
            ...options
        };
    }

    /**
     * Generate a PDF invoice from structured data
     * @param {Object} invoiceData - The invoice data structure
     * @param {string} outputPath - Path where the PDF should be saved
     */
    async generateInvoice(invoiceData, outputPath) {
        return new Promise((resolve, reject) => {
            try {
                // Create a new PDF document
                const doc = new PDFDocument({
                    size: 'A4',
                    margins: this.options.margins
                });

                // Pipe the PDF to a file
                const stream = fs.createWriteStream(outputPath);
                doc.pipe(stream);

                // Generate the invoice content
                this.generateHeader(doc, invoiceData.header);
                this.generateCompanyInfo(doc, invoiceData.company, invoiceData.client);
                this.generateInvoiceDetails(doc, invoiceData.invoice);
                
                // Add page break before items table if needed
                if (doc.y > 500) {
                    doc.addPage();
                }
                
                this.generateItemsTable(doc, invoiceData.items);
                this.generateSummary(doc, invoiceData.summary);
                this.generateFooter(doc, invoiceData.footer);

                // Finalize the PDF
                doc.end();

                stream.on('finish', () => {
                    resolve(outputPath);
                });

                stream.on('error', (error) => {
                    reject(error);
                });

            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Generate the invoice header with professional styling
     */
    generateHeader(doc, headerData) {
        if (!headerData) {
            // Default professional header
            doc.fontSize(this.options.fontSize.title)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary)
               .text('INVOICE', 50, 50, { align: 'center' });
            
            // Add subtle line under header
            doc.moveTo(100, 85)
               .lineTo(500, 85)
               .strokeColor(this.options.colors.accent)
               .lineWidth(2)
               .stroke();
            
            doc.moveDown(2);
            return;
        }

        // Custom header if provided
        if (headerData.title) {
            doc.fontSize(this.options.fontSize.title)
               .font(this.options.fonts.bold)
               .text(headerData.title, 50, 50, { align: 'center' });
        }
        
        doc.moveDown();
    }

    /**
     * Generate company and client information section with enhanced layout
     */
    generateCompanyInfo(doc, companyData, clientData) {
        const startY = doc.y + 10;
        const leftColumn = 50;
        const rightColumn = 320;

        // Company info (left side)
        if (companyData) {
            doc.fontSize(this.options.fontSize.heading)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary)
               .text('From:', leftColumn, startY);
            
            let currentY = startY + 25;
            doc.fontSize(this.options.fontSize.body)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary);
               
            if (companyData.name) {
                doc.text(companyData.name, leftColumn, currentY);
                currentY += 15;
            }
            
            doc.font(this.options.fonts.regular)
               .fillColor(this.options.colors.secondary);
               
            [companyData.address, companyData.city, companyData.email, companyData.phone]
                .filter(item => item)
                .forEach(item => {
                    doc.text(item, leftColumn, currentY);
                    currentY += 12;
                });
        }

        // Client info (right side)
        if (clientData) {
            doc.fontSize(this.options.fontSize.heading)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary)
               .text('To:', rightColumn, startY);
            
            let currentY = startY + 25;
            doc.fontSize(this.options.fontSize.body)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary);
               
            if (clientData.name) {
                doc.text(clientData.name, rightColumn, currentY);
                currentY += 15;
            }
            
            doc.font(this.options.fonts.regular)
               .fillColor(this.options.colors.secondary);
               
            [clientData.address, clientData.city, clientData.email]
                .filter(item => item)
                .forEach(item => {
                    doc.text(item, rightColumn, currentY);
                    currentY += 12;
                });
        }

        doc.y = Math.max(doc.y, startY + 120);
        doc.moveDown();
    }

    /**
     * Generate invoice details with enhanced styling
     */
    generateInvoiceDetails(doc, invoiceData) {
        if (!invoiceData) return;

        const detailsY = doc.y;
        const boxWidth = 200;
        const boxHeight = 80;
        const boxX = 350;
        
        // Draw details box
        doc.rect(boxX, detailsY, boxWidth, boxHeight)
           .fillAndStroke(this.options.colors.tableHeader, this.options.colors.border);
        
        doc.fillColor(this.options.colors.primary)
           .fontSize(this.options.fontSize.body)
           .font(this.options.fonts.regular);
        
        const detailItems = [
            { label: 'Invoice #:', value: invoiceData.number || '' },
            { label: 'Date:', value: invoiceData.date || '' },
            { label: 'Due Date:', value: invoiceData.dueDate || '' }
        ];
        
        let currentY = detailsY + 15;
        detailItems.forEach(item => {
            if (item.value) {
                doc.font(this.options.fonts.bold)
                   .text(item.label, boxX + 10, currentY, { width: 70 });
                doc.font(this.options.fonts.regular)
                   .text(item.value, boxX + 80, currentY, { width: 110 });
                currentY += 18;
            }
        });

        doc.y = detailsY + boxHeight + 20;
    }

    /**
     * Generate the items table with alternating row colors and proper formatting
     * Supports merged cells and professional styling to match the template
     */
    generateItemsTable(doc, items) {
        if (!items || !Array.isArray(items)) return;

        const tableTop = doc.y;
        const tableLeft = 50;
        const tableWidth = 495;
        const baseRowHeight = 30;
        
        // Enhanced column configuration with better proportions
        const columns = [
            { header: 'Description', width: 250, x: tableLeft, align: 'left' },
            { header: 'Qty', width: 60, x: tableLeft + 250, align: 'center' },
            { header: 'Rate', width: 90, x: tableLeft + 310, align: 'right' },
            { header: 'Amount', width: 95, x: tableLeft + 400, align: 'right' }
        ];

        // Draw header row with enhanced styling
        doc.rect(tableLeft, tableTop, tableWidth, baseRowHeight)
           .fillAndStroke(this.options.colors.tableHeader, this.options.colors.border);

        doc.fill(this.options.colors.primary)
           .fontSize(this.options.fontSize.body)
           .font('Helvetica-Bold');

        columns.forEach(col => {
            doc.text(col.header, col.x + 8, tableTop + 10, {
                width: col.width - 16,
                align: col.align
            });
        });

        // Process items and handle merged cells
        let currentY = tableTop + baseRowHeight;
        let lastDescription = '';
        let mergedRowStart = currentY;
        let mergedRowCount = 0;

        // Reset font for data rows
        doc.font('Helvetica');

        items.forEach((item, index) => {
            const description = item.description || '';
            const isNewGroup = description !== lastDescription && lastDescription !== '';
            const isMerged = description === lastDescription;
            
            // Calculate row height based on content
            const rowHeight = this.calculateRowHeight(doc, item, columns);
            
            // Alternate row colors (professional grey/white)
            const fillColor = index % 2 === 0 ? '#ffffff' : '#f8f9fa';
            
            doc.rect(tableLeft, currentY, tableWidth, rowHeight)
               .fillAndStroke(fillColor, this.options.colors.border);

            doc.fill(this.options.colors.primary);

            // Handle description column (support for merged cells)
            if (!isMerged) {
                // Draw description for new groups
                doc.fontSize(this.options.fontSize.body)
                   .text(description, columns[0].x + 8, currentY + 8, {
                       width: columns[0].width - 16,
                       align: 'left',
                       lineGap: 2
                   });
                lastDescription = description;
                mergedRowStart = currentY;
                mergedRowCount = 1;
            } else {
                mergedRowCount++;
                // For merged cells, we'll draw a border line to separate but keep description empty
                doc.moveTo(columns[1].x, currentY)
                   .lineTo(tableLeft + tableWidth, currentY)
                   .stroke(this.options.colors.border);
            }

            // Draw other columns
            doc.text(item.quantity || '', columns[1].x + 8, currentY + 8, {
                width: columns[1].width - 16,
                align: columns[1].align
            });

            doc.text(item.rate || '', columns[2].x + 8, currentY + 8, {
                width: columns[2].width - 16,
                align: columns[2].align
            });

            doc.text(item.amount || '', columns[3].x + 8, currentY + 8, {
                width: columns[3].width - 16,
                align: columns[3].align
            });

            currentY += rowHeight;
        });

        // Draw column separators
        doc.strokeColor(this.options.colors.border);
        columns.forEach((col, index) => {
            if (index > 0) {
                doc.moveTo(col.x, tableTop)
                   .lineTo(col.x, currentY)
                   .stroke();
            }
        });

        // Draw outer table border
        doc.rect(tableLeft, tableTop, tableWidth, currentY - tableTop)
           .stroke(this.options.colors.border);

        doc.y = currentY + 25;
    }

    /**
     * Calculate appropriate row height based on content
     */
    calculateRowHeight(doc, item, columns) {
        const baseHeight = 30;
        const description = item.description || '';
        
        // Estimate height needed for description text
        const textWidth = columns[0].width - 16;
        const fontSize = this.options.fontSize.body;
        
        // Simple estimation: if description is long, increase height
        if (description.length > 50) {
            return baseHeight + 15;
        } else if (description.length > 30) {
            return baseHeight + 8;
        }
        
        return baseHeight;
    }

    /**
     * Generate the summary section with totals
     */
    generateSummary(doc, summaryData) {
        if (!summaryData) return;

        const summaryX = 350;
        const startY = doc.y;

        doc.fontSize(this.options.fontSize.body);

        if (summaryData.subtotal) {
            doc.text('Subtotal:', summaryX, startY)
               .text(summaryData.subtotal, summaryX + 100, startY, { align: 'right', width: 100 });
        }

        if (summaryData.tax) {
            doc.text('Tax:', summaryX, doc.y + 5)
               .text(summaryData.tax, summaryX + 100, doc.y, { align: 'right', width: 100 });
        }

        if (summaryData.total) {
            doc.fontSize(this.options.fontSize.heading)
               .text('Total:', summaryX, doc.y + 10)
               .text(summaryData.total, summaryX + 100, doc.y, { align: 'right', width: 100 });
        }

        doc.moveDown(2);
    }

    /**
     * Generate the footer section
     */
    generateFooter(doc, footerData) {
        if (!footerData) return;

        doc.fontSize(this.options.fontSize.small)
           .fill(this.options.colors.secondary);

        if (footerData.notes) {
            doc.text('Notes:', 50, doc.y)
               .text(footerData.notes, 50, doc.y + 5);
        }

        if (footerData.terms) {
            doc.text('Terms:', 50, doc.y + 15)
               .text(footerData.terms, 50, doc.y + 5);
        }
    }
}

module.exports = InvoiceGenerator;