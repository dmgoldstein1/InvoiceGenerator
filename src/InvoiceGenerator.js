/**
 * Generated by GitHub Copilot (GPT-4)
 * Invoice Generator - Main PDF generation class
 * 
 * This class handles the creation of professionally formatted PDF invoices
 * from structured data, matching the styling of the provided template.
 */

const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

class InvoiceGenerator {
    constructor(options = {}) {
        this.options = {
            fontSize: {
                title: 28,
                heading: 16,
                subheading: 12,
                body: 10,
                small: 8
            },
            colors: {
                primary: '#2c3e50',
                secondary: '#7f8c8d',
                accent: '#3498db',
                tableHeader: '#ecf0f1',
                tableAlt: '#f8f9fa',
                border: '#bdc3c7',
                lightBorder: '#ecf0f1'
            },
            margins: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            fonts: {
                regular: 'Helvetica',
                bold: 'Helvetica-Bold',
                light: 'Helvetica'
            },
            ...options
        };
    }

    /**
     * Generate a PDF invoice from structured data
     * @param {Object} invoiceData - The invoice data structure
     * @param {string} outputPath - Path where the PDF should be saved
     */
    async generateInvoice(invoiceData, outputPath) {
        return new Promise((resolve, reject) => {
            try {
                // Create a new PDF document
                const doc = new PDFDocument({
                    size: 'A4',
                    margins: this.options.margins
                });

                // Pipe the PDF to a file
                const stream = fs.createWriteStream(outputPath);
                doc.pipe(stream);

                // Generate the invoice content
                this.generateHeader(doc, invoiceData.header);
                this.generateCompanyInfo(doc, invoiceData.company, invoiceData.client);
                this.generateInvoiceDetails(doc, invoiceData.invoice);
                
                // Add page break before items table if needed
                if (doc.y > 500) {
                    doc.addPage();
                }
                
                this.generateItemsTable(doc, invoiceData.items);
                this.generateSummary(doc, invoiceData.summary);
                this.generateFooter(doc, invoiceData.footer);

                // Finalize the PDF
                doc.end();

                stream.on('finish', () => {
                    resolve(outputPath);
                });

                stream.on('error', (error) => {
                    reject(error);
                });

            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Generate the invoice header with professional styling
     */
    generateHeader(doc, headerData) {
        if (!headerData) {
            // Default professional header
            doc.fontSize(this.options.fontSize.title)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary)
               .text('INVOICE', 50, 50, { align: 'center' });
            
            // Add subtle line under header
            doc.moveTo(100, 85)
               .lineTo(500, 85)
               .strokeColor(this.options.colors.accent)
               .lineWidth(2)
               .stroke();
            
            doc.moveDown(2);
            return;
        }

        // Custom header if provided
        if (headerData.title) {
            doc.fontSize(this.options.fontSize.title)
               .font(this.options.fonts.bold)
               .text(headerData.title, 50, 50, { align: 'center' });
        }
        
        doc.moveDown();
    }

    /**
     * Generate company and client information section with enhanced layout
     */
    generateCompanyInfo(doc, companyData, clientData) {
        const startY = doc.y + 10;
        const leftColumn = 50;
        const rightColumn = 320;

        // Company info (left side)
        if (companyData) {
            doc.fontSize(this.options.fontSize.heading)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary)
               .text('From:', leftColumn, startY);
            
            let currentY = startY + 25;
            doc.fontSize(this.options.fontSize.body)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary);
               
            if (companyData.name) {
                doc.text(companyData.name, leftColumn, currentY);
                currentY += 15;
            }
            
            doc.font(this.options.fonts.regular)
               .fillColor(this.options.colors.secondary);
               
            [companyData.address, companyData.city, companyData.email, companyData.phone]
                .filter(item => item)
                .forEach(item => {
                    doc.text(item, leftColumn, currentY);
                    currentY += 12;
                });
        }

        // Client info (right side)
        if (clientData) {
            doc.fontSize(this.options.fontSize.heading)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary)
               .text('To:', rightColumn, startY);
            
            let currentY = startY + 25;
            doc.fontSize(this.options.fontSize.body)
               .font(this.options.fonts.bold)
               .fillColor(this.options.colors.primary);
               
            if (clientData.name) {
                doc.text(clientData.name, rightColumn, currentY);
                currentY += 15;
            }
            
            doc.font(this.options.fonts.regular)
               .fillColor(this.options.colors.secondary);
               
            [clientData.address, clientData.city, clientData.email]
                .filter(item => item)
                .forEach(item => {
                    doc.text(item, rightColumn, currentY);
                    currentY += 12;
                });
        }

        doc.y = Math.max(doc.y, startY + 120);
        doc.moveDown();
    }

    /**
     * Generate invoice details with enhanced styling
     */
    generateInvoiceDetails(doc, invoiceData) {
        if (!invoiceData) return;

        const detailsY = doc.y;
        const boxWidth = 200;
        const boxHeight = 80;
        const boxX = 350;
        
        // Draw details box
        doc.rect(boxX, detailsY, boxWidth, boxHeight)
           .fillAndStroke(this.options.colors.tableHeader, this.options.colors.border);
        
        doc.fillColor(this.options.colors.primary)
           .fontSize(this.options.fontSize.body)
           .font(this.options.fonts.regular);
        
        const detailItems = [
            { label: 'Invoice #:', value: invoiceData.number || '' },
            { label: 'Date:', value: invoiceData.date || '' },
            { label: 'Due Date:', value: invoiceData.dueDate || '' }
        ];
        
        let currentY = detailsY + 15;
        detailItems.forEach(item => {
            if (item.value) {
                doc.font(this.options.fonts.bold)
                   .text(item.label, boxX + 10, currentY, { width: 70 });
                doc.font(this.options.fonts.regular)
                   .text(item.value, boxX + 80, currentY, { width: 110 });
                currentY += 18;
            }
        });

        doc.y = detailsY + boxHeight + 20;
    }

    /**
     * Generate the items table with alternating row colors and proper formatting
     * Supports merged cells, dynamic columns, and auto-calculation
     */
    generateItemsTable(doc, items) {
        if (!items || !Array.isArray(items)) return;

        // Auto-calculate amounts if missing and ensure all items have amounts
        const processedItems = items.map(item => this.processItemForGeneration(item));

        const tableTop = doc.y;
        const tableLeft = 50;
        const tableWidth = 495;
        const baseRowHeight = 30;
        
        // Dynamically determine which columns to show based on data
        const columns = this.generateColumnConfig(processedItems, tableLeft, tableWidth);

        // Draw header row with enhanced styling
        doc.rect(tableLeft, tableTop, tableWidth, baseRowHeight)
           .fillAndStroke(this.options.colors.tableHeader, this.options.colors.border);

        doc.fill(this.options.colors.primary)
           .fontSize(this.options.fontSize.body)
           .font('Helvetica-Bold');

        columns.forEach(col => {
            doc.text(col.header, col.x + 8, tableTop + 10, {
                width: col.width - 16,
                align: col.align
            });
        });

        // Process items and handle merged cells
        let currentY = tableTop + baseRowHeight;
        let lastDescription = '';
        let mergedRowStart = currentY;
        let mergedRowCount = 0;

        // Reset font for data rows
        doc.font('Helvetica');

        processedItems.forEach((item, index) => {
            const description = item.description || '';
            const isNewGroup = description !== lastDescription && lastDescription !== '';
            const isMerged = description === lastDescription;
            
            // Calculate row height based on content
            const rowHeight = this.calculateRowHeight(doc, item, columns);
            
            // Alternate row colors (professional grey/white)
            const fillColor = index % 2 === 0 ? '#ffffff' : '#f8f9fa';
            
            doc.rect(tableLeft, currentY, tableWidth, rowHeight)
               .fillAndStroke(fillColor, this.options.colors.border);

            doc.fill(this.options.colors.primary);

            // Draw all columns dynamically
            columns.forEach((col, colIndex) => {
                const value = this.getItemValue(item, col.field);
                
                if (col.field === 'description') {
                    // Handle description column (support for merged cells)
                    if (!isMerged) {
                        doc.fontSize(this.options.fontSize.body)
                           .text(value, col.x + 8, currentY + 8, {
                               width: col.width - 16,
                               align: col.align,
                               lineGap: 2
                           });
                        lastDescription = description;
                        mergedRowStart = currentY;
                        mergedRowCount = 1;
                    } else {
                        mergedRowCount++;
                        // For merged cells, draw a border line to separate but keep description empty
                        if (colIndex < columns.length - 1) {
                            doc.moveTo(columns[colIndex + 1].x, currentY)
                               .lineTo(tableLeft + tableWidth, currentY)
                               .stroke(this.options.colors.border);
                        }
                    }
                } else {
                    // Handle all other columns normally
                    doc.text(value, col.x + 8, currentY + 8, {
                        width: col.width - 16,
                        align: col.align
                    });
                }
            });

            currentY += rowHeight;
        });

        // Draw column separators
        doc.strokeColor(this.options.colors.border);
        columns.forEach((col, index) => {
            if (index > 0) {
                doc.moveTo(col.x, tableTop)
                   .lineTo(col.x, currentY)
                   .stroke();
            }
        });

        // Draw outer table border
        doc.rect(tableLeft, tableTop, tableWidth, currentY - tableTop)
           .stroke(this.options.colors.border);

        doc.y = currentY + 25;
    }

    /**
     * Process an item for generation: auto-calculate amount if needed
     */
    processItemForGeneration(item) {
        const processedItem = { ...item };
        
        // Auto-calculate amount if not provided but quantity/hours and rate provided
        if (!processedItem.amount) {
            const quantity = this.parseNumericValue(processedItem.quantity || processedItem.hours);
            const rate = this.parseNumericValue(processedItem.rate || processedItem.hourlyRate);
            
            if (quantity !== null && rate !== null) {
                const calculatedAmount = quantity * rate;
                processedItem.amount = this.formatCurrency(calculatedAmount);
            }
        }
        
        return processedItem;
    }

    /**
     * Parse numeric value from string (handles currency symbols, etc.)
     */
    parseNumericValue(value) {
        if (!value) return null;
        
        // Remove currency symbols, commas, and extra spaces
        const cleanValue = value.toString().replace(/[$,\s]/g, '');
        
        // Handle hour formats like "5 hrs", "10.5 hours"
        const hourMatch = cleanValue.match(/^(\d+(?:\.\d+)?)\s*h/i);
        if (hourMatch) {
            return parseFloat(hourMatch[1]);
        }
        
        const numericValue = parseFloat(cleanValue);
        return isNaN(numericValue) ? null : numericValue;
    }

    /**
     * Format a number as currency
     */
    formatCurrency(amount) {
        return `$${amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`;
    }

    /**
     * Generate dynamic column configuration based on available data
     */
    generateColumnConfig(items, tableLeft, tableWidth) {
        // Determine which columns have data
        const hasDate = items.some(item => item.date);
        const hasHours = items.some(item => item.hours);
        const hasQuantity = items.some(item => item.quantity && !item.hours);
        const hasRate = items.some(item => item.rate);
        const hasHourlyRate = items.some(item => item.hourlyRate);
        
        const columns = [];
        let currentX = tableLeft;
        
        // Always show description
        const descWidth = hasDate ? 180 : (hasHours || hasQuantity ? 220 : 250);
        columns.push({
            field: 'description',
            header: 'Description',
            width: descWidth,
            x: currentX,
            align: 'left'
        });
        currentX += descWidth;
        
        // Date column if present
        if (hasDate) {
            columns.push({
                field: 'date',
                header: 'Date',
                width: 80,
                x: currentX,
                align: 'center'
            });
            currentX += 80;
        }
        
        // Quantity/Hours column
        if (hasHours) {
            columns.push({
                field: 'hours',
                header: 'Hours',
                width: 60,
                x: currentX,
                align: 'center'
            });
        } else if (hasQuantity) {
            columns.push({
                field: 'quantity',
                header: 'Qty',
                width: 60,
                x: currentX,
                align: 'center'
            });
        }
        if (hasHours || hasQuantity) {
            currentX += 60;
        }
        
        // Rate column
        if (hasHourlyRate) {
            columns.push({
                field: 'hourlyRate',
                header: 'Hourly Rate',
                width: 85,
                x: currentX,
                align: 'right'
            });
            currentX += 85;
        } else if (hasRate) {
            columns.push({
                field: 'rate',
                header: 'Rate',
                width: 85,
                x: currentX,
                align: 'right'
            });
            currentX += 85;
        }
        
        // Amount column (always present)
        const remainingWidth = tableLeft + tableWidth - currentX;
        columns.push({
            field: 'amount',
            header: 'Amount',
            width: remainingWidth,
            x: currentX,
            align: 'right'
        });
        
        return columns;
    }

    /**
     * Get the appropriate value for a field from an item
     */
    getItemValue(item, field) {
        return item[field] || '';
    }

    /**
     * Calculate appropriate row height based on content
     */
    calculateRowHeight(doc, item, columns) {
        const baseHeight = 30;
        const description = item.description || '';
        
        // Estimate height needed for description text
        const textWidth = columns[0].width - 16;
        const fontSize = this.options.fontSize.body;
        
        // Simple estimation: if description is long, increase height
        if (description.length > 50) {
            return baseHeight + 15;
        } else if (description.length > 30) {
            return baseHeight + 8;
        }
        
        return baseHeight;
    }

    /**
     * Generate the summary section with totals
     */
    generateSummary(doc, summaryData) {
        if (!summaryData) return;

        const summaryX = 350;
        const startY = doc.y;

        doc.fontSize(this.options.fontSize.body);

        if (summaryData.subtotal) {
            doc.text('Subtotal:', summaryX, startY)
               .text(summaryData.subtotal, summaryX + 100, startY, { align: 'right', width: 100 });
        }

        if (summaryData.tax) {
            doc.text('Tax:', summaryX, doc.y + 5)
               .text(summaryData.tax, summaryX + 100, doc.y, { align: 'right', width: 100 });
        }

        if (summaryData.total) {
            doc.fontSize(this.options.fontSize.heading)
               .text('Total:', summaryX, doc.y + 10)
               .text(summaryData.total, summaryX + 100, doc.y, { align: 'right', width: 100 });
        }

        doc.moveDown(2);
    }

    /**
     * Generate the footer section
     */
    generateFooter(doc, footerData) {
        if (!footerData) return;

        doc.fontSize(this.options.fontSize.small)
           .fill(this.options.colors.secondary);

        if (footerData.notes) {
            doc.text('Notes:', 50, doc.y)
               .text(footerData.notes, 50, doc.y + 5);
        }

        if (footerData.terms) {
            doc.text('Terms:', 50, doc.y + 15)
               .text(footerData.terms, 50, doc.y + 5);
        }
    }
}

module.exports = InvoiceGenerator;