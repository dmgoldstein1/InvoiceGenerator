/**
 * Generated by GitHub Copilot (GPT-4)
 * Markdown Parser for Invoice Data
 * 
 * This module parses markdown-like input files and converts them
 * into structured data for invoice generation.
 */

const fs = require('fs');
const yaml = require('js-yaml');

class InvoiceParser {
    constructor() {
        this.defaultStructure = {
            header: {},
            company: {},
            client: {},
            invoice: {},
            items: [],
            summary: {},
            footer: {},
            // Cover letter data for template generation
            coverLetter: {
                greeting: '',
                content: '',
                closing: 'Sincerely,'
            },
            cc: [] // CC recipients for business correspondence
        };
    }

    /**
     * Parse an invoice file and return structured data
     * @param {string} filePath - Path to the invoice input file
     * @returns {Object} Structured invoice data
     */
    parseFile(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            return this.parseContent(content);
        } catch (error) {
            throw new Error(`Failed to parse invoice file: ${error.message}`);
        }
    }

    /**
     * Parse invoice content from string
     * @param {string} content - The invoice content
     * @returns {Object} Structured invoice data
     */
    parseContent(content) {
        const result = { ...this.defaultStructure };
        
        // Check if the content is a YAML document
        if (content.trim().startsWith('---')) {
            try {
                // Find the YAML content after the front matter
                const lines = content.split('\n');
                let yamlStart = -1;
                let dashCount = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === '---') {
                        dashCount++;
                        if (dashCount === 2) {
                            yamlStart = i + 1;
                            break;
                        }
                    }
                }
                
                if (yamlStart !== -1) {
                    // Get all content after the second ---
                    const yamlContent = lines.slice(yamlStart).join('\n').trim();
                    
                    if (yamlContent) {
                        const yamlData = yaml.load(yamlContent);
                        if (yamlData && typeof yamlData === 'object') {
                            // Process the YAML data
                            Object.assign(result, yamlData);
                            
                            // Process items for auto-calculation
                            if (result.items && Array.isArray(result.items)) {
                                result.items = result.items.map(item => this.processItem(item));
                            }
                            
                            this.validateInvoiceData(result);
                            return result;
                        }
                    }
                }
            } catch (e) {
                console.warn('Failed to parse as YAML, falling back to section parsing:', e.message);
            }
        }
        
        // Fallback to section-based parsing for markdown format
        const sections = this.splitIntoSections(content);
        
        // Parse each section
        sections.forEach(section => {
            this.parseSection(section, result);
        });

        // Validate required fields
        this.validateInvoiceData(result);
        
        return result;
    }

    /**
     * Split content into logical sections based on headers
     */
    splitIntoSections(content) {
        const lines = content.split('\n');
        const sections = [];
        let currentSection = null;

        lines.forEach(line => {
            const trimmed = line.trim();
            
            // Check for section headers (lines starting with # or ---)
            if (trimmed.startsWith('#') || trimmed.startsWith('---')) {
                if (currentSection) {
                    sections.push(currentSection);
                }
                currentSection = {
                    header: trimmed,
                    content: []
                };
            } else if (currentSection) {
                currentSection.content.push(line);
            } else {
                // Content before any header goes to a default section
                if (!sections.find(s => s.header === 'default')) {
                    sections.push({
                        header: 'default',
                        content: []
                    });
                }
                sections[sections.length - 1].content.push(line);
            }
        });

        if (currentSection) {
            sections.push(currentSection);
        }

        return sections;
    }

    /**
     * Parse individual section content
     */
    parseSection(section, result) {
        const header = section.header.toLowerCase();
        const content = section.content.join('\n').trim();

        if (!content) return;

        // Handle YAML front matter
        if (header.includes('---') || header === 'default') {
            try {
                const yamlData = yaml.load(content);
                if (yamlData && typeof yamlData === 'object') {
                    Object.assign(result, yamlData);
                }
            } catch (e) {
                // If not valid YAML, try to parse as key-value pairs
                this.parseKeyValuePairs(content, result);
            }
            return;
        }

        // Handle specific sections
        if (header.includes('company') || header.includes('from')) {
            this.parseCompanyInfo(content, result.company);
        } else if (header.includes('summary') || header.includes('total')) {
            this.parseSummary(content, result.summary);
        } else if (header.includes('client') || (header.includes('to') && !header.includes('total')) || header.includes('bill')) {
            this.parseCompanyInfo(content, result.client);
        } else if (header.includes('invoice') || header.includes('details')) {
            this.parseInvoiceDetails(content, result.invoice);
        } else if (header.includes('items') || header.includes('table') || header.includes('services')) {
            this.parseItemsTable(content, result.items);
        } else if (header.includes('footer') || header.includes('notes') || header.includes('terms')) {
            this.parseFooter(content, result.footer);
        }
    }

    /**
     * Parse key-value pairs from text
     */
    parseKeyValuePairs(content, target) {
        const lines = content.split('\n');
        lines.forEach(line => {
            const colonIndex = line.indexOf(':');
            if (colonIndex > 0) {
                const key = line.substring(0, colonIndex).trim().toLowerCase();
                const value = line.substring(colonIndex + 1).trim();
                
                // Map common key variations
                const keyMap = {
                    'invoice number': 'number',
                    'invoice #': 'number',
                    'due date': 'dueDate',
                    'company name': 'name',
                    'client name': 'name'
                };
                
                const finalKey = keyMap[key] || key.replace(/\s+/g, '');
                if (value) {
                    target[finalKey] = value;
                }
            }
        });
    }

    /**
     * Parse company/client information
     */
    parseCompanyInfo(content, target) {
        const lines = content.split('\n').filter(line => line.trim());
        
        lines.forEach((line, index) => {
            const trimmed = line.trim();
            if (!trimmed) return;

            if (trimmed.includes(':')) {
                const [key, value] = trimmed.split(':').map(s => s.trim());
                const normalizedKey = key.toLowerCase().replace(/\s+/g, '');
                target[normalizedKey] = value;
            } else {
                // First line without colon is usually the name
                if (index === 0 && !target.name) {
                    target.name = trimmed;
                } else if (!target.address) {
                    target.address = trimmed;
                } else if (!target.city && trimmed.includes(',')) {
                    target.city = trimmed;
                } else if (trimmed.includes('@')) {
                    target.email = trimmed;
                } else if (trimmed.match(/[\d\s\-\(\)]+/)) {
                    target.phone = trimmed;
                }
            }
        });
    }

    /**
     * Parse invoice details (number, date, etc.)
     */
    parseInvoiceDetails(content, target) {
        this.parseKeyValuePairs(content, target);
    }

    /**
     * Parse items table from markdown table format or YAML format
     * Now supports auto-calculation and enhanced fields (date, hours, hourlyRate)
     */
    parseItemsTable(content, targetArray) {
        const lines = content.split('\n').filter(line => line.trim());
        
        // Check if content is YAML format (contains "items:" and "-")
        if (content.includes('items:') && content.includes('- description:')) {
            try {
                const yamlData = yaml.load(content);
                if (yamlData && yamlData.items && Array.isArray(yamlData.items)) {
                    // Process each item for auto-calculation and field normalization
                    const processedItems = yamlData.items.map(item => this.processItem(item));
                    targetArray.push(...processedItems);
                    return;
                }
            } catch (e) {
                console.warn('Failed to parse items as YAML, falling back to table parsing');
            }
        }
        
        // Original markdown table parsing logic
        let headerFound = false;
        let headers = [];

        lines.forEach(line => {
            const trimmed = line.trim();
            if (!trimmed || trimmed.startsWith('|---')) return;

            if (trimmed.startsWith('|')) {
                const cells = trimmed.split('|').map(cell => cell.trim()).filter(cell => cell);
                
                if (!headerFound) {
                    headers = cells.map(h => this.normalizeColumnHeader(h));
                    headerFound = true;
                } else {
                    const item = {};
                    cells.forEach((cell, index) => {
                        if (headers[index]) {
                            item[headers[index]] = cell;
                        }
                    });
                    if (Object.keys(item).length > 0) {
                        targetArray.push(this.processItem(item));
                    }
                }
            }
        });
    }

    /**
     * Normalize column headers to standard field names
     */
    normalizeColumnHeader(header) {
        const normalized = header.toLowerCase().replace(/\s+/g, '');
        
        // Map various column header variations to standard field names
        const headerMap = {
            'description': 'description',
            'desc': 'description',
            'item': 'description',
            'service': 'description',
            'task': 'description',
            
            'date': 'date',
            'workdate': 'date',
            'servicedate': 'date',
            
            'quantity': 'quantity',
            'qty': 'quantity',
            'amount': 'quantity',
            'units': 'quantity',
            
            'hours': 'hours',
            'hrs': 'hours',
            'time': 'hours',
            'duration': 'hours',
            'numberofhours': 'hours',
            
            'rate': 'rate',
            'unitrate': 'rate',
            'price': 'rate',
            'cost': 'rate',
            
            'hourlyrate': 'hourlyRate',
            'hrrate': 'hourlyRate',
            'hourlyprice': 'hourlyRate',
            'rateperhour': 'hourlyRate',
            
            'amount': 'amount',
            'total': 'amount',
            'subtotal': 'amount',
            'linetotal': 'amount'
        };
        
        return headerMap[normalized] || normalized;
    }

    /**
     * Process an individual item: auto-calculate amount and normalize fields
     */
    processItem(item) {
        const processedItem = { ...item };
        
        // Auto-calculate amount if not provided but quantity/hours and rate provided
        if (!processedItem.amount) {
            const quantity = this.parseNumericValue(processedItem.quantity || processedItem.hours);
            const rate = this.parseNumericValue(processedItem.rate || processedItem.hourlyRate);
            
            if (quantity !== null && rate !== null) {
                const calculatedAmount = quantity * rate;
                processedItem.amount = this.formatCurrency(calculatedAmount);
            }
        }
        
        return processedItem;
    }

    /**
     * Parse numeric value from string (handles currency symbols, etc.)
     */
    parseNumericValue(value) {
        if (!value) return null;
        
        // Remove currency symbols, commas, and extra spaces
        const cleanValue = value.toString().replace(/[$,\s]/g, '');
        
        // Handle hour formats like "5 hrs", "10.5 hours"
        const hourMatch = cleanValue.match(/^(\d+(?:\.\d+)?)\s*h/i);
        if (hourMatch) {
            return parseFloat(hourMatch[1]);
        }
        
        const numericValue = parseFloat(cleanValue);
        return isNaN(numericValue) ? null : numericValue;
    }

    /**
     * Format a number as currency
     */
    formatCurrency(amount) {
        return `$${amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`;
    }

    /**
     * Parse summary section with totals - handle both YAML and key-value formats
     */
    parseSummary(content, target) {
        // Try YAML parsing first
        if (content.includes('summary:')) {
            try {
                const yamlData = yaml.load(content);
                if (yamlData && yamlData.summary && typeof yamlData.summary === 'object') {
                    Object.assign(target, yamlData.summary);
                    return;
                }
            } catch (e) {
                console.warn('Failed to parse summary as YAML, falling back to key-value parsing');
            }
        }
        
        // Fall back to key-value parsing
        this.parseKeyValuePairs(content, target);
    }

    /**
     * Parse footer section - handle both YAML and key-value formats
     */
    parseFooter(content, target) {
        // Try YAML parsing first
        if (content.includes('footer:')) {
            try {
                const yamlData = yaml.load(content);
                if (yamlData && yamlData.footer && typeof yamlData.footer === 'object') {
                    Object.assign(target, yamlData.footer);
                    return;
                }
            } catch (e) {
                console.warn('Failed to parse footer as YAML, falling back to key-value parsing');
            }
        }
        
        // Fall back to original parsing logic
        const lines = content.split('\n');
        let currentKey = null;
        let currentContent = [];

        lines.forEach(line => {
            const trimmed = line.trim();
            if (trimmed.includes(':')) {
                // Save previous content
                if (currentKey && currentContent.length > 0) {
                    target[currentKey] = currentContent.join('\n').trim();
                }
                
                // Start new content
                const [key, value] = trimmed.split(':').map(s => s.trim());
                currentKey = key.toLowerCase().replace(/\s+/g, '');
                currentContent = value ? [value] : [];
            } else if (currentKey && trimmed) {
                currentContent.push(trimmed);
            }
        });

        // Save last content
        if (currentKey && currentContent.length > 0) {
            target[currentKey] = currentContent.join('\n').trim();
        }
    }

    /**
     * Validate required invoice data
     */
    validateInvoiceData(data) {
        const requiredFields = ['invoice.number', 'company.name', 'client.name'];
        const missing = [];

        requiredFields.forEach(field => {
            const [section, key] = field.split('.');
            if (!data[section] || !data[section][key]) {
                missing.push(field);
            }
        });

        if (missing.length > 0) {
            console.warn(`Warning: Missing recommended fields: ${missing.join(', ')}`);
        }
    }
}

module.exports = InvoiceParser;