#!/usr/bin/env node

/**
 * Generated by GitHub Copilot (GPT-4o)
 * Robust PDF Text Extractor
 * 
 * Alternative PDF text extraction that handles various PDF formats
 * and XRef issues that might occur with PDFKit-generated files.
 */

const fs = require('fs');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class RobustPdfExtractor {
  constructor() {
    this.logsDir = 'logs';
    if (!fs.existsSync(this.logsDir)) {
      fs.mkdirSync(this.logsDir, { recursive: true });
    }
  }
  
  log(message) {
    console.log(message);
  }
  
  async extractTextPdftotext(pdfPath) {
    try {
      // Try pdftotext first (part of poppler-utils)
      const { stdout } = await execAsync(`pdftotext "${pdfPath}" -`);
      return stdout;
    } catch (error) {
      this.log(`pdftotext failed: ${error.message}`);
      return null;
    }
  }
  
  async extractTextStrings(pdfPath) {
    try {
      // Use strings command as fallback
      const { stdout } = await execAsync(`strings "${pdfPath}"`);
      return stdout;
    } catch (error) {
      this.log(`strings failed: ${error.message}`);
      return null;
    }
  }
  
  async extractTextHexdump(pdfPath) {
    try {
      // Use hexdump to get raw text
      const { stdout } = await execAsync(`hexdump -C "${pdfPath}" | grep -E '[a-zA-Z]{3,}'`);
      return stdout;
    } catch (error) {
      this.log(`hexdump failed: ${error.message}`);
      return null;
    }
  }
  
  parseExtractedText(rawText) {
    if (!rawText) return null;
    
    // Clean up the text
    const lines = rawText.split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);
    
    const analysis = {
      invoiceNumber: null,
      title: null,
      columnHeaders: [],
      phoneNumbers: [],
      totals: [],
      dates: [],
      allText: rawText
    };
    
    // Extract invoice number
    for (const line of lines) {
      const invoiceMatch = line.match(/Invoice #(\d+)/i);
      if (invoiceMatch) {
        analysis.invoiceNumber = invoiceMatch[1];
        analysis.title = line;
        break;
      }
    }
    
    // Extract column headers
    const headerKeywords = ['Date', 'Description', 'Time', 'Hours', 'Rate', 'Amount'];
    for (const line of lines) {
      const foundHeaders = headerKeywords.filter(header => line.includes(header));
      if (foundHeaders.length >= 3) {
        analysis.columnHeaders = foundHeaders;
        break;
      }
    }
    
    // Extract phone numbers
    const phoneRegex = /\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g;
    const phoneMatches = rawText.match(phoneRegex) || [];
    analysis.phoneNumbers = phoneMatches;
    
    // Extract totals
    const totalRegex = /Total[:\s]*\$?(\d+[\d,.]*)/gi;
    let match;
    while ((match = totalRegex.exec(rawText)) !== null) {
      analysis.totals.push(match[1]);
    }
    
    return analysis;
  }
  
  async analyzePdf(pdfPath) {
    this.log(`\nAnalyzing PDF with multiple methods: ${pdfPath}`);
    
    let extractedText = null;
    let method = 'unknown';
    
    // Try multiple extraction methods
    const methods = [
      { name: 'pdftotext', func: () => this.extractTextPdftotext(pdfPath) },
      { name: 'strings', func: () => this.extractTextStrings(pdfPath) },
      { name: 'hexdump', func: () => this.extractTextHexdump(pdfPath) }
    ];
    
    for (const methodInfo of methods) {
      try {
        this.log(`Trying ${methodInfo.name}...`);
        const result = await methodInfo.func();
        if (result && result.trim().length > 100) {
          extractedText = result;
          method = methodInfo.name;
          this.log(`Success with ${method}`);
          break;
        }
      } catch (error) {
        this.log(`${methodInfo.name} failed: ${error.message}`);
      }
    }
    
    if (!extractedText) {
      this.log('All extraction methods failed');
      return null;
    }
    
    const analysis = this.parseExtractedText(extractedText);
    analysis.extractionMethod = method;
    
    this.log(`Extracted with ${method}:`);
    this.log(`- Invoice: ${analysis.invoiceNumber}`);
    this.log(`- Title: ${analysis.title}`);
    this.log(`- Headers: ${analysis.columnHeaders.join(', ')}`);
    this.log(`- Phones: ${analysis.phoneNumbers.join(', ')}`);
    this.log(`- Totals: ${analysis.totals.join(', ')}`);
    
    return analysis;
  }
}

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 1) {
    console.log('Usage: node robust-pdf-extractor.js <pdf-file>');
    process.exit(1);
  }
  
  const pdfPath = args[0];
  const extractor = new RobustPdfExtractor();
  
  extractor.analyzePdf(pdfPath)
    .then(result => {
      if (result) {
        console.log('\n=== Analysis Complete ===');
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.log('Failed to extract text from PDF');
        process.exit(1);
      }
    })
    .catch(error => {
      console.error('Error:', error.message);
      process.exit(1);
    });
}

module.exports = RobustPdfExtractor;
