#!/usr/bin/env node

/**
 * Generated by GitHub Copilot (GPT-4o)
 * Invoice and Cover Letter PDF Generator - Main Entry Point
 * 
 * Enhanced version with improved styling, logging, and iterative improvements
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const PDFDocument = require('pdfkit');

class InvoiceGeneratorV2 {
  constructor() {
    this.outputDir = path.join(__dirname, 'output');
    this.logsDir = path.join(__dirname, 'logs');
    
    // Ensure directories exist
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
    if (!fs.existsSync(this.logsDir)) {
      fs.mkdirSync(this.logsDir, { recursive: true });
    }
    
    // Enhanced color scheme for professional appearance
    this.colors = {
      primary: '#2c5aa0',      // Professional blue
      secondary: '#666666',     // Medium gray
      text: '#333333',         // Dark gray for text
      light: '#f8f9fa',        // Very light gray for alternating rows
      lightBlue: '#e8f1ff',    // Light blue for subtle highlights
      white: '#ffffff',
      success: '#28a745',      // Green for positive values
      border: '#dee2e6'        // Light border color
    };
    
    this.setupLogging();
  }
  
  setupLogging() {
    const timestamp = Date.now();
    this.logFile = path.join(this.logsDir, `invoice-generator-log-${timestamp}.log`);
    this.log('Invoice Generator V2 initialized');
  }
  
  log(message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;
    fs.appendFileSync(this.logFile, logEntry);
    console.log(message);
  }
  
  async loadYamlData(filePath) {
    try {
      this.log(`Loading YAML data from: ${filePath}`);
      const fileContents = fs.readFileSync(filePath, 'utf8');
      const data = yaml.load(fileContents);
      this.log(`Successfully loaded YAML data with ${data.invoice_items?.length || 0} invoice items`);
      return data;
    } catch (error) {
      this.log(`Error loading YAML file: ${error.message}`);
      throw new Error(`Failed to load YAML file: ${error.message}`);
    }
  }
  
  formatDate(dateStr) {
    if (typeof dateStr === 'string' && dateStr.includes('/')) {
      const parts = dateStr.split('/');
      if (parts.length === 3) {
        const month = parseInt(parts[0]);
        const day = parseInt(parts[1]);
        const year = parseInt(parts[2]);
        return `${month}/${day}/${year}`;
      }
    }
    return dateStr;
  }
  
  formatCurrency(amount) {
    if (typeof amount === 'string' && amount.startsWith('$')) {
      return amount;
    }
    return `$${parseFloat(amount).toFixed(2)}`;
  }
  
  calculateLineTotal(hours, rate) {
    if (!hours || !rate) return '';
    const rateNum = typeof rate === 'string' ? parseFloat(rate.replace('$', '')) : rate;
    return parseFloat(hours) * rateNum;
  }
  
  calculateTotal(items) {
    let total = 0;
    items.forEach(item => {
      if (item.hours && item.hourly_rate) {
        const rate = typeof item.hourly_rate === 'string' ? 
          parseFloat(item.hourly_rate.replace('$', '')) : item.hourly_rate;
        total += parseFloat(item.hours) * rate;
      } else if (item.amount) {
        total += parseFloat(item.amount);
      }
    });
    return total;
  }
  
  // Enhanced text wrapping for better line breaks
  wrapText(doc, text, maxWidth, options = {}) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const testWidth = doc.widthOfString(testLine, options);
      
      if (testWidth <= maxWidth) {
        currentLine = testLine;
      } else {
        if (currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          // Word is too long, force break
          lines.push(word);
        }
      }
    });
    
    if (currentLine) {
      lines.push(currentLine);
    }
    
    return lines;
  }
  
  async generateCoverLetter(data, outputPath) {
    this.log('Generating cover letter...');
    const doc = new PDFDocument({ 
      size: 'letter', 
      margins: { top: 54, bottom: 54, left: 54, right: 54 } 
    });
    
    const stream = fs.createWriteStream(outputPath);
    doc.pipe(stream);
    
    // Professional letterhead with enhanced styling
    doc.font('Times-Bold')
       .fontSize(18)
       .fillColor(this.colors.primary)
       .text(data.invoice_details.from_contact.name, { align: 'center' });
    
    doc.font('Times-Italic')
       .fontSize(12)
       .fillColor(this.colors.secondary)
       .text(data.invoice_details.from_contact.title, { align: 'center' });
    
    doc.moveDown(0.3);
    
    doc.font('Times-Roman')
       .fontSize(10)
       .fillColor(this.colors.text)
       .text(data.invoice_details.from_contact.address, { align: 'center' })
       .text(data.invoice_details.from_contact.phone, { align: 'center' })
       .text(data.invoice_details.from_contact.email, { align: 'center' });
    
    // Enhanced decorative line
    doc.moveDown(0.5);
    doc.strokeColor(this.colors.primary)
       .lineWidth(2)
       .moveTo(54, doc.y)
       .lineTo(doc.page.width - 54, doc.y)
       .stroke();
    
    doc.moveDown(1.5);
    
    // Date with better positioning
    doc.font('Times-Roman')
       .fontSize(11)
       .fillColor(this.colors.text)
       .text(this.formatDate(data.invoice_details.invoice_date), { align: 'right' });
    
    doc.moveDown(1);
    
    // Enhanced recipient section
    doc.font('Times-Bold')
       .fontSize(12)
       .fillColor(this.colors.primary)
       .text(data.invoice_details.to_contact.name, { align: 'left' });
    
    if (data.invoice_details.to_contact.company) {
      doc.font('Times-Italic')
         .fontSize(11)
         .fillColor(this.colors.text)
         .text(data.invoice_details.to_contact.company);
    }
    
    doc.font('Times-Roman')
       .fontSize(10)
       .fillColor(this.colors.secondary)
       .text(data.invoice_details.to_contact.address)
       .text(data.invoice_details.to_contact.phone)
       .text(data.invoice_details.to_contact.email);
    
    doc.moveDown(1.2);
    
    // Greeting
    doc.font('Times-Roman')
       .fontSize(11)
       .fillColor(this.colors.text)
       .text(data.cover_letter.greeting);
    
    doc.moveDown(0.6);
    
    // Body with improved paragraph handling
    const paragraphs = data.cover_letter.body.split('\n\n').filter(p => p.trim().length > 0);
    paragraphs.forEach((paragraph, index) => {
      doc.font('Times-Roman')
         .fontSize(11)
         .fillColor(this.colors.text)
         .text(paragraph.trim(), { 
           align: 'justify', 
           lineGap: 3,
           paragraphGap: 8
         });
      
      if (index < paragraphs.length - 1) {
        doc.moveDown(0.4);
      }
    });
    
    doc.moveDown(1);
    
    // Closing
    doc.font('Times-Roman')
       .fontSize(11)
       .text(data.cover_letter.closing);
    
    doc.moveDown(0.6);
    
    // Signature with emphasis
    doc.font('Times-Bold')
       .fontSize(12)
       .fillColor(this.colors.primary)
       .text(data.cover_letter.signature);
    
    // Enhanced CC section
    if (data.invoice_details.cc_contacts && data.invoice_details.cc_contacts.length > 0) {
      doc.moveDown(1.2);
      doc.strokeColor(this.colors.border)
         .lineWidth(1)
         .moveTo(54, doc.y)
         .lineTo(doc.page.width - 54, doc.y)
         .stroke();
      
      doc.moveDown(0.4);
      doc.font('Times-Bold')
         .fontSize(10)
         .fillColor(this.colors.secondary)
         .text('CC:');
      
      data.invoice_details.cc_contacts.forEach(contact => {
        doc.font('Times-Roman')
           .fontSize(10)
           .fillColor(this.colors.text)
           .text(`${contact.name} - ${contact.email}`);
      });
    }
    
    doc.end();
    
    return new Promise((resolve, reject) => {
      stream.on('finish', () => {
        this.log(`Cover letter generated successfully: ${outputPath}`);
        resolve();
      });
      stream.on('error', (err) => {
        this.log(`Error generating cover letter: ${err.message}`);
        reject(err);
      });
    });
  }
  
  async generateInvoice(data, outputPath) {
    this.log('Generating invoice...');
    const doc = new PDFDocument({ 
      size: 'letter', 
      margins: { top: 36, bottom: 36, left: 36, right: 36 } 
    });
    
    const stream = fs.createWriteStream(outputPath);
    doc.pipe(stream);
    
    // Enhanced invoice header
    doc.font('Helvetica-Bold')
       .fontSize(28)
       .fillColor(this.colors.primary)
       .text('INVOICE', 50, 50);
    
    // Professional invoice number section
    const rightMargin = doc.page.width - 50;
    doc.font('Helvetica-Bold')
       .fontSize(11)
       .fillColor(this.colors.secondary)
       .text('Invoice #', rightMargin - 100, 65, { align: 'right', width: 100 });
    
    doc.font('Helvetica-Bold')
       .fontSize(18)
       .fillColor(this.colors.primary)
       .text(data.invoice_details.invoice_number, rightMargin - 100, 80, { align: 'right', width: 100 });
    
    doc.font('Helvetica')
       .fontSize(10)
       .fillColor(this.colors.secondary)
       .text(`Date: ${this.formatDate(data.invoice_details.invoice_date)}`, rightMargin - 120, 105, { align: 'right', width: 120 });
    
    // Professional header line
    doc.strokeColor(this.colors.primary)
       .lineWidth(3)
       .moveTo(50, 130)
       .lineTo(rightMargin, 130)
       .stroke();
    
    // Enhanced contact sections
    const contactY = 150;
    
    // From section with better styling
    doc.font('Helvetica-Bold')
       .fontSize(11)
       .fillColor(this.colors.primary)
       .text('FROM', 50, contactY);
    
    doc.strokeColor(this.colors.border)
       .lineWidth(1)
       .moveTo(50, contactY + 18)
       .lineTo(270, contactY + 18)
       .stroke();
    
    let fromY = contactY + 28;
    doc.font('Helvetica-Bold')
       .fontSize(11)
       .fillColor(this.colors.text)
       .text(data.invoice_details.from_contact.name, 50, fromY);
    
    fromY += 15;
    if (data.invoice_details.from_contact.title) {
      doc.font('Helvetica-Oblique')
         .fontSize(9)
         .fillColor(this.colors.secondary)
         .text(data.invoice_details.from_contact.title, 50, fromY);
      fromY += 12;
    }
    
    doc.font('Helvetica')
       .fontSize(9)
       .fillColor(this.colors.secondary)
       .text(data.invoice_details.from_contact.address, 50, fromY);
    fromY += 12;
    doc.text(data.invoice_details.from_contact.phone, 50, fromY);
    fromY += 12;
    doc.text(data.invoice_details.from_contact.email, 50, fromY);
    
    // To section with enhanced styling
    doc.font('Helvetica-Bold')
       .fontSize(11)
       .fillColor(this.colors.primary)
       .text('BILL TO', 330, contactY);
    
    doc.strokeColor(this.colors.border)
       .lineWidth(1)
       .moveTo(330, contactY + 18)
       .lineTo(rightMargin, contactY + 18)
       .stroke();
    
    let toY = contactY + 28;
    doc.font('Helvetica-Bold')
       .fontSize(11)
       .fillColor(this.colors.text)
       .text(data.invoice_details.to_contact.name, 330, toY);
    
    toY += 15;
    if (data.invoice_details.to_contact.company) {
      doc.font('Helvetica-Bold')
         .fontSize(10)
         .fillColor(this.colors.text)
         .text(data.invoice_details.to_contact.company, 330, toY);
      toY += 12;
    }
    
    doc.font('Helvetica')
       .fontSize(9)
       .fillColor(this.colors.secondary)
       .text(data.invoice_details.to_contact.address, 330, toY);
    toY += 12;
    doc.text(data.invoice_details.to_contact.phone, 330, toY);
    toY += 12;
    doc.text(data.invoice_details.to_contact.email, 330, toY);
    
    // Enhanced table with better spacing and typography
    const tableTop = 290;
    const tableLeft = 50;
    const tableWidth = rightMargin - tableLeft;
    const headerHeight = 30;
    
    // Table header with gradient-like effect
    doc.rect(tableLeft, tableTop, tableWidth, headerHeight)
       .fillColor(this.colors.primary)
       .fill();
    
    // Column widths optimized for content
    const cols = {
      date: { x: tableLeft + 8, width: 60 },
      desc: { x: tableLeft + 75, width: 220 },
      time: { x: tableLeft + 305, width: 70 },
      hours: { x: tableLeft + 385, width: 40 },
      rate: { x: tableLeft + 435, width: 50 },
      total: { x: tableLeft + 495, width: 70 }
    };
    
    doc.font('Helvetica-Bold')
       .fontSize(9)
       .fillColor('white');
    
    doc.text('DATE', cols.date.x, tableTop + 10);
    doc.text('DESCRIPTION', cols.desc.x, tableTop + 10);
    doc.text('TIME', cols.time.x, tableTop + 10);
    doc.text('HRS', cols.hours.x, tableTop + 10);
    doc.text('RATE', cols.rate.x, tableTop + 10);
    doc.text('TOTAL', cols.total.x, tableTop + 10);
    
    // Enhanced table rows with better alternating colors
    let currentY = tableTop + headerHeight;
    const rowHeight = 32;
    
    data.invoice_items.forEach((item, index) => {
      const isEven = index % 2 === 0;
      
      // Alternating row backgrounds with subtle colors
      doc.rect(tableLeft, currentY, tableWidth, rowHeight)
         .fillColor(isEven ? this.colors.light : this.colors.white)
         .fill();
      
      const textY = currentY + 10;
      
      // Date with emphasis
      doc.font('Helvetica-Bold')
         .fontSize(9)
         .fillColor(this.colors.primary)
         .text(this.formatDate(item.date), cols.date.x, textY);
      
      // Description with proper text wrapping
      const wrappedDesc = this.wrapText(doc, item.description, cols.desc.width - 10, { font: 'Helvetica', size: 9 });
      doc.font('Helvetica')
         .fontSize(9)
         .fillColor(this.colors.text);
      
      wrappedDesc.forEach((line, lineIndex) => {
        doc.text(line, cols.desc.x, textY + (lineIndex * 10), { width: cols.desc.width - 10 });
      });
      
      // Time range
      if (item.start_time && item.stop_time) {
        doc.font('Helvetica')
           .fontSize(8)
           .fillColor(this.colors.secondary)
           .text(`${item.start_time}-${item.stop_time}`, cols.time.x, textY);
      }
      
      // Hours
      if (item.hours) {
        doc.font('Helvetica-Bold')
           .fontSize(9)
           .fillColor(this.colors.text)
           .text(item.hours.toString(), cols.hours.x, textY, { align: 'center', width: cols.hours.width });
      }
      
      // Rate
      if (item.hourly_rate) {
        doc.font('Helvetica-Bold')
           .fontSize(9)
           .fillColor(this.colors.text)
           .text(this.formatCurrency(item.hourly_rate), cols.rate.x, textY, { align: 'right', width: cols.rate.width });
      }
      
      // Total with emphasis
      let total;
      if (item.hours && item.hourly_rate) {
        total = this.formatCurrency(this.calculateLineTotal(item.hours, item.hourly_rate));
      } else if (item.amount) {
        total = this.formatCurrency(item.amount);
      }
      
      doc.font('Helvetica-Bold')
         .fontSize(9)
         .fillColor(this.colors.primary)
         .text(total, cols.total.x, textY, { align: 'right', width: cols.total.width });
      
      currentY += rowHeight;
    });
    
    // Enhanced total section
    currentY += 20;
    const totalAmount = this.calculateTotal(data.invoice_items);
    
    // Subtle background for total area
    doc.rect(tableLeft + 350, currentY - 5, tableWidth - 300, 40)
       .fillColor(this.colors.lightBlue)
       .fill();
    
    doc.font('Helvetica-Bold')
       .fontSize(14)
       .fillColor(this.colors.secondary)
       .text('TOTAL AMOUNT:', tableLeft + 360, currentY + 8);
    
    doc.font('Helvetica-Bold')
       .fontSize(16)
       .fillColor(this.colors.primary)
       .text(this.formatCurrency(totalAmount), cols.total.x, currentY + 8, { align: 'right', width: cols.total.width });
    
    // Professional line above total
    doc.strokeColor(this.colors.primary)
       .lineWidth(2)
       .moveTo(tableLeft + 360, currentY + 3)
       .lineTo(rightMargin - 10, currentY + 3)
       .stroke();
    
    // Enhanced footer
    currentY += 80;
    doc.strokeColor(this.colors.border)
       .lineWidth(1)
       .moveTo(50, currentY)
       .lineTo(rightMargin, currentY)
       .stroke();
    
    doc.font('Helvetica')
       .fontSize(9)
       .fillColor(this.colors.secondary)
       .text('Thank you for your business! Payment terms: Net 30 days.', 50, currentY + 15, { 
         align: 'center',
         width: tableWidth
       });
    
    this.log(`Invoice calculated total: ${this.formatCurrency(totalAmount)}`);
    this.log(`Invoice contains ${data.invoice_items.length} line items`);
    
    doc.end();
    
    return new Promise((resolve, reject) => {
      stream.on('finish', () => {
        this.log(`Invoice generated successfully: ${outputPath}`);
        resolve();
      });
      stream.on('error', (err) => {
        this.log(`Error generating invoice: ${err.message}`);
        reject(err);
      });
    });
  }
  
  async generateFromYaml(yamlPath, outputBaseName) {
    try {
      this.log(`Starting PDF generation for: ${yamlPath}`);
      const data = await this.loadYamlData(yamlPath);
      
      // Generate cover letter
      const coverLetterPath = path.join(this.outputDir, `${outputBaseName}-cover-letter.pdf`);
      await this.generateCoverLetter(data, coverLetterPath);
      
      // Generate invoice
      const invoicePath = path.join(this.outputDir, `${outputBaseName}-invoice.pdf`);
      await this.generateInvoice(data, invoicePath);
      
      this.log('PDF generation completed successfully');
      
      return {
        coverLetter: coverLetterPath,
        invoice: invoicePath,
        logFile: this.logFile
      };
    } catch (error) {
      this.log(`Error generating PDFs: ${error.message}`);
      throw error;
    }
  }
}

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 1) {
    console.log('Usage: node generator.js <yaml-file> [output-base-name]');
    console.log('Example: node generator.js invoice.yaml client-invoice');
    process.exit(1);
  }
  
  const yamlFile = args[0];
  const outputBaseName = args[1] || `test-${Date.now()}`;
  
  const generator = new InvoiceGeneratorV2();
  generator.generateFromYaml(yamlFile, outputBaseName)
    .then(files => {
      console.log('\n=== Generation Complete ===');
      console.log('Cover Letter:', files.coverLetter);
      console.log('Invoice:', files.invoice);
      console.log('Log File:', files.logFile);
      console.log('\nFiles saved in:', path.dirname(files.coverLetter));
    })
    .catch(error => {
      console.error('Failed to generate PDFs:', error.message);
      process.exit(1);
    });
}

module.exports = InvoiceGeneratorV2;
