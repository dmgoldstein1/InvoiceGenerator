#!/usr/bin/env node

/**
 * Generated by GitHub Copilot (GPT-4o)
 * Machine Vision PDF Template Analyzer
 * 
 * Combines machine vision (image analysis) with standard PDF analysis
 * to identify visual and stylistic differences between template PDFs
 * and generated outputs for iterative improvement.
 */

const fs = require('fs');
const path = require('path');
const pdf = require('pdf-parse');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class MachineVisionAnalyzer {
  constructor() {
    this.outputDir = path.join(__dirname, 'analysis');
    this.imagesDir = path.join(this.outputDir, 'images');
    this.reportsDir = path.join(this.outputDir, 'reports');
    this.logsDir = path.join(__dirname, 'logs');
    
    // Ensure directories exist
    [this.outputDir, this.imagesDir, this.reportsDir, this.logsDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
    
    this.setupLogging();
  }
  
  setupLogging() {
    const timestamp = Date.now();
    this.logFile = path.join(this.logsDir, `machine-vision-log-${timestamp}.log`);
    this.log('Machine Vision Analyzer initialized');
    this.log('Combining image analysis with PDF text analysis');
  }
  
  log(message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;
    fs.appendFileSync(this.logFile, logEntry);
    console.log(message);
  }
  
  async convertPdfToImage(pdfPath, outputImagePath, dpi = 150) {
    try {
      this.log(`Converting PDF to image: ${pdfPath} -> ${outputImagePath}`);
      
      // Check if ImageMagick is available
      try {
        await execAsync('which convert');
      } catch (error) {
        this.log('ImageMagick not found, trying alternative methods...');
        
        // Try using pdftoppm if available
        try {
          await execAsync('which pdftoppm');
          const command = `pdftoppm -png -r ${dpi} -singlefile "${pdfPath}" "${outputImagePath.replace('.png', '')}"`;
          await execAsync(command);
          this.log(`Successfully converted using pdftoppm: ${outputImagePath}`);
          return outputImagePath;
        } catch (error2) {
          this.log('pdftoppm not found either, using Node.js PDF analysis only');
          return null;
        }
      }
      
      // Use ImageMagick convert
      const command = `convert -density ${dpi} "${pdfPath}[0]" "${outputImagePath}"`;
      await execAsync(command);
      this.log(`Successfully converted using ImageMagick: ${outputImagePath}`);
      return outputImagePath;
      
    } catch (error) {
      this.log(`Error converting PDF to image: ${error.message}`);
      return null;
    }
  }
  
  async analyzePdfText(pdfPath) {
    try {
      this.log(`Analyzing PDF text structure: ${pdfPath}`);
      
      const dataBuffer = fs.readFileSync(pdfPath);
      const data = await pdf(dataBuffer);
      
      const analysis = {
        pages: data.numpages,
        textLength: data.text.length,
        text: data.text,
        info: data.info || {},
        metadata: data.metadata || {},
        
        // Extract specific elements
        invoiceNumber: this.extractInvoiceNumber(data.text),
        title: this.extractTitle(data.text),
        columnHeaders: this.extractColumnHeaders(data.text),
        phoneNumbers: this.extractPhoneNumbers(data.text),
        totals: this.extractTotals(data.text),
        dates: this.extractDates(data.text)
      };
      
      this.log(`Extracted invoice number: ${analysis.invoiceNumber}`);
      this.log(`Extracted title: ${analysis.title}`);
      this.log(`Column headers: ${analysis.columnHeaders.join(' | ')}`);
      
      return analysis;
      
    } catch (error) {
      this.log(`Error analyzing PDF text: ${error.message}`);
      return null;
    }
  }
  
  extractInvoiceNumber(text) {
    const match = text.match(/Invoice #(\d+)/i);
    return match ? match[1] : null;
  }
  
  extractTitle(text) {
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    // Look for lines containing "Invoice #"
    const titleLine = lines.find(line => line.includes('Invoice #'));
    return titleLine || null;
  }
  
  extractColumnHeaders(text) {
    // Look for table headers
    const headerPatterns = [
      /Date.*Job Description.*Time.*Hours.*Rate.*Amount/i,
      /Date.*Description.*Hours.*Rate.*Amount/i
    ];
    
    const lines = text.split('\n');
    for (const line of lines) {
      for (const pattern of headerPatterns) {
        if (pattern.test(line)) {
          // Split the line to get individual headers
          const headers = line.split(/\s{2,}/).filter(h => h.trim().length > 0);
          return headers;
        }
      }
    }
    
    // Fallback: look for common headers
    const commonHeaders = ['Date', 'Job Description', 'Time(s)', 'Hours', 'Hourly Rate', 'Amount Billed', 'Amount'];
    const foundHeaders = [];
    
    for (const header of commonHeaders) {
      if (text.includes(header)) {
        foundHeaders.push(header);
      }
    }
    
    return foundHeaders;
  }
  
  extractPhoneNumbers(text) {
    const phonePattern = /\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g;
    const matches = text.match(phonePattern) || [];
    return matches.map(phone => phone.trim());
  }
  
  extractTotals(text) {
    const totalPattern = /Total:\s*\$?([\d,]+\.?\d{0,2})/gi;
    const matches = [];
    let match;
    
    while ((match = totalPattern.exec(text)) !== null) {
      matches.push(match[1]);
    }
    
    return matches;
  }
  
  extractDates(text) {
    const datePatterns = [
      /\w+day,\s+\w+\s+\d{1,2},\s+\d{4}/g,  // "Thursday, April 11, 2024"
      /\d{1,2}\/\d{1,2}\/\d{4}/g,            // "4/11/2024"
      /\w+\s+\d{1,2},\s+\d{4}/g              // "April 11, 2024"
    ];
    
    const dates = [];
    for (const pattern of datePatterns) {
      const matches = text.match(pattern) || [];
      dates.push(...matches);
    }
    
    return [...new Set(dates)]; // Remove duplicates
  }
  
  async compareDocuments(templatePath, generatedPath, reportName) {
    this.log(`\n=== Comparing Documents ===`);
    this.log(`Template: ${templatePath}`);
    this.log(`Generated: ${generatedPath}`);
    
    const comparison = {
      template: await this.analyzePdfText(templatePath),
      generated: await this.analyzePdfText(generatedPath),
      differences: [],
      machineVision: null
    };
    
    if (!comparison.template || !comparison.generated) {
      this.log('Error: Could not analyze one or both documents');
      return comparison;
    }
    
    // Text-based comparison
    this.compareTexts(comparison);
    
    // Machine vision comparison (if images available)
    const templateImage = await this.convertPdfToImage(
      templatePath, 
      path.join(this.imagesDir, `template-${reportName}.png`)
    );
    
    const generatedImage = await this.convertPdfToImage(
      generatedPath,
      path.join(this.imagesDir, `generated-${reportName}.png`)
    );
    
    if (templateImage && generatedImage) {
      comparison.machineVision = await this.compareImages(templateImage, generatedImage);
    }
    
    // Generate report
    const reportPath = path.join(this.reportsDir, `${reportName}-comparison.json`);
    fs.writeFileSync(reportPath, JSON.stringify(comparison, null, 2));
    
    this.generateHumanReadableReport(comparison, reportName);
    
    return comparison;
  }
  
  compareTexts(comparison) {
    const { template, generated } = comparison;
    
    // Compare invoice numbers
    if (template.invoiceNumber !== generated.invoiceNumber) {
      comparison.differences.push({
        type: 'invoice_number',
        template: template.invoiceNumber,
        generated: generated.invoiceNumber,
        severity: 'high'
      });
    }
    
    // Compare titles
    if (template.title !== generated.title) {
      comparison.differences.push({
        type: 'title',
        template: template.title,
        generated: generated.title,
        severity: 'high'
      });
    }
    
    // Compare column headers
    const templateHeaders = template.columnHeaders.join('|');
    const generatedHeaders = generated.columnHeaders.join('|');
    
    if (templateHeaders !== generatedHeaders) {
      comparison.differences.push({
        type: 'column_headers',
        template: template.columnHeaders,
        generated: generated.columnHeaders,
        severity: 'medium'
      });
    }
    
    // Compare phone formatting
    if (template.phoneNumbers.length > 0 && generated.phoneNumbers.length > 0) {
      const templatePhone = template.phoneNumbers[0];
      const generatedPhone = generated.phoneNumbers[0];
      
      if (templatePhone !== generatedPhone) {
        comparison.differences.push({
          type: 'phone_formatting',
          template: templatePhone,
          generated: generatedPhone,
          severity: 'low'
        });
      }
    }
    
    // Compare totals
    if (template.totals.length > 0 && generated.totals.length > 0) {
      const templateTotal = template.totals[template.totals.length - 1];
      const generatedTotal = generated.totals[generated.totals.length - 1];
      
      if (templateTotal !== generatedTotal) {
        comparison.differences.push({
          type: 'totals',
          template: templateTotal,
          generated: generatedTotal,
          severity: 'high'
        });
      }
    }
  }
  
  async compareImages(image1Path, image2Path) {
    // Placeholder for image comparison
    // In a real implementation, you would use image processing libraries
    return {
      available: false,
      message: 'Image comparison requires additional dependencies (sharp, jimp, or opencv)',
      recommendation: 'Install image processing libraries for pixel-level comparison'
    };
  }
  
  generateHumanReadableReport(comparison, reportName) {
    const reportPath = path.join(this.reportsDir, `${reportName}-report.md`);
    
    let report = `# Visual Comparison Report: ${reportName}\n\n`;
    report += `**Generated by GitHub Copilot (GPT-4o)**\n`;
    report += `**Analysis Date**: ${new Date().toISOString()}\n\n`;
    
    report += `## Summary\n\n`;
    report += `- **Differences Found**: ${comparison.differences.length}\n`;
    report += `- **Template Document**: Analyzed successfully\n`;
    report += `- **Generated Document**: Analyzed successfully\n\n`;
    
    if (comparison.differences.length === 0) {
      report += `âœ… **Perfect Match**: No differences detected!\n\n`;
    } else {
      report += `## Differences Detected\n\n`;
      
      comparison.differences.forEach((diff, index) => {
        report += `### ${index + 1}. ${diff.type.toUpperCase()} (${diff.severity} severity)\n\n`;
        report += `**Template**: \`${diff.template}\`\n\n`;
        report += `**Generated**: \`${diff.generated}\`\n\n`;
        
        // Add fix recommendations
        switch (diff.type) {
          case 'title':
            report += `**Fix**: Update invoice title format to match template exactly.\n\n`;
            break;
          case 'column_headers':
            report += `**Fix**: Adjust table column headers to match template text.\n\n`;
            break;
          case 'phone_formatting':
            report += `**Fix**: Update phone number formatting including spacing.\n\n`;
            break;
          default:
            report += `**Fix**: Address ${diff.type} formatting discrepancy.\n\n`;
        }
      });
    }
    
    report += `## Template Analysis\n\n`;
    report += `- **Invoice Number**: ${comparison.template.invoiceNumber}\n`;
    report += `- **Title**: ${comparison.template.title}\n`;
    report += `- **Column Headers**: ${comparison.template.columnHeaders.join(', ')}\n`;
    report += `- **Phone Numbers**: ${comparison.template.phoneNumbers.join(', ')}\n`;
    report += `- **Totals**: ${comparison.template.totals.join(', ')}\n\n`;
    
    report += `## Generated Analysis\n\n`;
    report += `- **Invoice Number**: ${comparison.generated.invoiceNumber}\n`;
    report += `- **Title**: ${comparison.generated.title}\n`;
    report += `- **Column Headers**: ${comparison.generated.columnHeaders.join(', ')}\n`;
    report += `- **Phone Numbers**: ${comparison.generated.phoneNumbers.join(', ')}\n`;
    report += `- **Totals**: ${comparison.generated.totals.join(', ')}\n\n`;
    
    if (comparison.machineVision) {
      report += `## Machine Vision Analysis\n\n`;
      if (comparison.machineVision.available) {
        report += `Machine vision analysis completed.\n\n`;
      } else {
        report += `${comparison.machineVision.message}\n\n`;
        report += `**Recommendation**: ${comparison.machineVision.recommendation}\n\n`;
      }
    }
    
    fs.writeFileSync(reportPath, report);
    this.log(`Human-readable report generated: ${reportPath}`);
  }
  
  async runFullAnalysis(templatePaths, generatedPaths) {
    this.log(`\n=== Starting Full Machine Vision Analysis ===`);
    
    const results = [];
    
    // Compare cover letters
    if (templatePaths.coverLetter && generatedPaths.coverLetter) {
      this.log(`\nAnalyzing Cover Letters...`);
      const coverLetterResult = await this.compareDocuments(
        templatePaths.coverLetter,
        generatedPaths.coverLetter,
        'cover-letter'
      );
      results.push({ type: 'cover-letter', result: coverLetterResult });
    }
    
    // Compare invoices
    if (templatePaths.invoice && generatedPaths.invoice) {
      this.log(`\nAnalyzing Invoices...`);
      const invoiceResult = await this.compareDocuments(
        templatePaths.invoice,
        generatedPaths.invoice,
        'invoice'
      );
      results.push({ type: 'invoice', result: invoiceResult });
    }
    
    // Generate summary report
    this.generateSummaryReport(results);
    
    return results;
  }
  
  generateSummaryReport(results) {
    const summaryPath = path.join(this.reportsDir, 'analysis-summary.md');
    
    let summary = `# Machine Vision Analysis Summary\n\n`;
    summary += `**Generated by GitHub Copilot (GPT-4o)**\n`;
    summary += `**Analysis Date**: ${new Date().toISOString()}\n\n`;
    
    let totalDifferences = 0;
    let criticalIssues = 0;
    
    results.forEach(({ type, result }) => {
      const differences = result.differences.length;
      totalDifferences += differences;
      
      const critical = result.differences.filter(d => d.severity === 'high').length;
      criticalIssues += critical;
      
      summary += `## ${type.toUpperCase()} Analysis\n\n`;
      summary += `- **Differences**: ${differences}\n`;
      summary += `- **Critical Issues**: ${critical}\n`;
      
      if (differences === 0) {
        summary += `- **Status**: âœ… Perfect Match\n\n`;
      } else {
        summary += `- **Status**: âš ï¸ Needs Adjustment\n\n`;
        
        result.differences.forEach(diff => {
          summary += `  - ${diff.type}: ${diff.severity} severity\n`;
        });
        summary += `\n`;
      }
    });
    
    summary += `## Overall Assessment\n\n`;
    
    if (totalDifferences === 0) {
      summary += `ðŸŽ‰ **EXCELLENT**: Perfect template matching achieved!\n\n`;
      summary += `All generated documents match the template style exactly.\n`;
    } else if (criticalIssues === 0) {
      summary += `âœ… **GOOD**: Minor adjustments needed.\n\n`;
      summary += `${totalDifferences} minor differences detected.\n`;
    } else {
      summary += `âš ï¸ **NEEDS WORK**: ${criticalIssues} critical issues found.\n\n`;
      summary += `Total differences: ${totalDifferences}\n`;
    }
    
    summary += `\n## Next Steps\n\n`;
    
    if (totalDifferences > 0) {
      summary += `1. Review individual comparison reports\n`;
      summary += `2. Implement fixes for identified differences\n`;
      summary += `3. Re-generate PDFs and re-analyze\n`;
      summary += `4. Repeat until perfect match achieved\n`;
    } else {
      summary += `ðŸŽ¯ Template matching is complete! No further action needed.\n`;
    }
    
    fs.writeFileSync(summaryPath, summary);
    this.log(`Analysis summary generated: ${summaryPath}`);
    
    console.log('\n' + summary);
  }
}

// CLI usage
if (require.main === module) {
  const analyzer = new MachineVisionAnalyzer();
  
  const templatePaths = {
    invoice: 'Invoice 21 for SAV-for-template.pdf',
    // coverLetter: 'Cover Letter Template.pdf' // Add if available
  };
  
  const generatedPaths = {
    invoice: 'output/precise-template-test-invoice.pdf',
    coverLetter: 'output/precise-template-test-cover-letter.pdf'
  };
  
  analyzer.runFullAnalysis(templatePaths, generatedPaths)
    .then(results => {
      console.log('\n=== Machine Vision Analysis Complete ===');
      console.log(`Results saved in: ${analyzer.reportsDir}`);
      console.log(`Images saved in: ${analyzer.imagesDir}`);
      console.log(`Logs saved in: ${analyzer.logFile}`);
    })
    .catch(error => {
      console.error('Analysis failed:', error.message);
      process.exit(1);
    });
}

module.exports = MachineVisionAnalyzer;
